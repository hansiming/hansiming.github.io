<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="hansiming" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="专注于大数据，云计算，Java后端">
<meta property="og:type" content="website">
<meta property="og:title" content="Han 博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Han 博客">
<meta property="og:description" content="专注于大数据，云计算，Java后端">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Han 博客">
<meta name="twitter:description" content="专注于大数据，云计算，Java后端">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Han 博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?61353e23b8e42a3b785fab01ab47ccba";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Han 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/09/hdfs lazy persist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="韩思明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Han 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/09/hdfs lazy persist/" itemprop="url">HDFS内存存储原理（Lazy Persist）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T20:23:55+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hdfs/" itemprop="url" rel="index">
                    <span itemprop="name">hdfs</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><div align="center"><br> <img src="https://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/images/LazyPersistWrites.png" alt="图1" align="center"><br></div><br><div align="center"><br> 图一<br></div>

<p>HDFS支持由Data Node管理的写入到堆栈内存的功能。Data Node会异步的将数据从内存持久化至磁盘，从而在性能敏感的IO Path中移去昂贵的磁盘IO和校验，因此我们称之为Lazy Persist。HDFS尽可能的保证在Lazy Persist策略下的持久性。在副本还未持久化至磁盘，节点重启了，则有可能会发生罕见的数据遗失。我们可以选择Lazy Persist Writes的策略来减少延迟，但可能会损失一定的持久性。</p>
<p>上文描述的原理在图一的表示其实是<strong>4,6</strong>的步骤.写数据的RAM,然后异步的写到Disk.前面几个步骤是如何设置StorageType的操作,这个在下文种会具体提到.所以上图所示的大体步骤可以归纳为如下:</p>
<ol>
<li>对目标文件目录设置StoragePolicy为LAZY_PERSIST的内存存储策略.</li>
<li>客户端进程向NameNode发起创建/写文件的请求.</li>
<li>请求到具体的DataNode,DataNode会把这些数据块写入RAM内存中,同时启动异步线程服务将内存数据持久化到磁盘上.</li>
</ol>
<p>内存的异步持久化存储,就是明显不同于其他介质存储数据的地方.这应该也是LAZY_PERSIST的名称的源由吧,数据不是马上落盘,而是”lazy persisit”懒惰的方式,延时的处理.</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>在之前的篇幅中已经提到过,数据存储的同时会有另外一批数据会被异步的持久化,所以这里一定会涉及到多个服务对象的合作.这些服务对象的指挥者是FsDatasetImpl.他是一个掌管DataNode所有磁盘读写数据的管家.</p>
<p>在FsDatasetImpl中,与内存存储相关的服务对象有如下的3个.</p>
<div align="center"><br> <img src="http://img.blog.csdn.net/20160529195437234" width="800" height="350" alt="图2" align="center"><br></div><br><div align="center"><br> 图二<br></div>

<ul>
<li><p><strong>LazyWriter</strong>:lazyWriter是一个线程服务,此线程会不断的循环着从数据块列表中取出数据块,加入到异步持久化线程池RamDiskAsyncLazyPersistService中去执行.</p>
</li>
<li><p><strong>RamDiskAsyncLazyPersistService</strong>:此对象就是异步持久化线程服务,里面针对每一个磁盘块设置一个对应的线程池,然后需要持久化到给定的磁盘块的数据块会被提交到对应的线程池中去.每个线程池的最大线程数为1.</p>
</li>
<li><p><strong>RamDiskReplicaLruTracker</strong>:副本块跟踪类,此类种维护了所有已持久化,未持久化的副本以及总副本数据信息.所以当一个副本被最终存储到内存种后,相应的会有副本所属队列信息的变更.其次当节点内存不足的时候,部分距离最近最久没有被访问的副本块会在此类中被移除.</p>
</li>
</ul>
<h2 id="RamDiskReplicaLruTracker"><a href="#RamDiskReplicaLruTracker" class="headerlink" title="RamDiskReplicaLruTracker"></a>RamDiskReplicaLruTracker</h2><p>在以上3者中,RamDiskReplicaLruTracker的角色起到了一个中间人的角色.因为他内部维护了多个关系的数据块信息.主要的就是以下3类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RamDiskReplicaLruTracker</span> <span class="keyword">extends</span> <span class="title">RamDiskReplicaTracker</span> </span>&#123;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * &lt;block pool ID &lt;block ID, RamDiskRelicaLru&gt;</div><div class="line">   * Map of blockpool ID to &lt;map of blockID to ReplicaInfo&gt;.</div><div class="line">   */</div><div class="line">  Map&lt;String, Map&lt;Long, RamDiskReplicaLru&gt;&gt; replicaMaps;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 将会被写入到磁盘的副本队列</div><div class="line">   * Queue of replicas that need to be written to disk.</div><div class="line">   * Stale entries are GC'd by dequeueNextReplicaToPersist.</div><div class="line">   */</div><div class="line">  Queue&lt;RamDiskReplicaLru&gt; replicasNotPersisted;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 已经被持久化的副本，按照上次使用的时间排序</div><div class="line">   * Map of persisted replicas ordered by their last use times.</div><div class="line">   */</div><div class="line">  TreeMultimap&lt;Long, RamDiskReplicaLru&gt; replicasPersisted;</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div align="center"><br> <img src="http://img.blog.csdn.net/20160529195555378" width="800" height="350" alt="图3" align="center"><br></div><br><div align="center"><br> 图三<br></div>

<p>三种数据块的关系如图三所示，replicaMaps是<block pool="" id="" <block="" id,="" ramdiskrelicalru="">的Map（关于Block pool，在上篇<a href="http://www.cszjo.com/2017/08/06/HDFS%20Federation/" target="_blank" rel="external">HDFS Federation</a>中有介绍），Ram副本都会在replicaMaps中存在。replicasNotPersisted保存的是将会写入到磁盘的队列。replicasPersisted保存的是已经被持久化的副本，并且按照上次使用的时间排序。</block></p>
<p>列出几个RamDiskReplicaLruTracker类中关键的方法</p>
<ul>
<li><strong>addReplica</strong> 新添副本</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addReplica</span><span class="params">(<span class="keyword">final</span> String bpid, <span class="keyword">final</span> <span class="keyword">long</span> blockId,</span></span></div><div class="line">                             <span class="keyword">final</span> FsVolumeImpl transientVolume) &#123;</div><div class="line">  Map&lt;Long, RamDiskReplicaLru&gt; map = replicaMaps.get(bpid);</div><div class="line">  <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;Long, RamDiskReplicaLru&gt;();</div><div class="line">    replicaMaps.put(bpid, map);</div><div class="line">  &#125;</div><div class="line">  RamDiskReplicaLru ramDiskReplicaLru = <span class="keyword">new</span> RamDiskReplicaLru(bpid, blockId, transientVolume);</div><div class="line">  map.put(blockId, ramDiskReplicaLru);</div><div class="line">  <span class="comment">//将ramDiskReplicaLru放入到replicasNotPersisted之中</span></div><div class="line">  replicasNotPersisted.add(ramDiskReplicaLru);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>dequeueNextReplicaToPersist</strong> 从replicasNotPersisted队列中拿出下一个将要被持久化的副本</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="comment">//从replicasNotPersisted中拿到下个将会被持久化的block</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> RamDiskReplicaLru <span class="title">dequeueNextReplicaToPersist</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">while</span> (replicasNotPersisted.size() != <span class="number">0</span>) &#123;</div><div class="line">    RamDiskReplicaLru ramDiskReplicaLru = replicasNotPersisted.remove();</div><div class="line">    Map&lt;Long, RamDiskReplicaLru&gt; replicaMap =</div><div class="line">        replicaMaps.get(ramDiskReplicaLru.getBlockPoolId());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (replicaMap != <span class="keyword">null</span> &amp;&amp; replicaMap.get(ramDiskReplicaLru.getBlockId()) != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> ramDiskReplicaLru;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// The replica no longer exists, look for the next one.</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>recordStartLazyPersist</strong> 记录开始Lazy Persist持久化操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">recordStartLazyPersist</span><span class="params">(</span></span></div><div class="line">     <span class="keyword">final</span> String bpid, <span class="keyword">final</span> <span class="keyword">long</span> blockId, FsVolumeImpl checkpointVolume) &#123;</div><div class="line">   Map&lt;Long, RamDiskReplicaLru&gt; map = replicaMaps.get(bpid);</div><div class="line">   RamDiskReplicaLru ramDiskReplicaLru = map.get(blockId);</div><div class="line"><span class="comment">//设置被持久化的Volume</span></div><div class="line">   ramDiskReplicaLru.setLazyPersistVolume(checkpointVolume);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>recordEndLazyPersist</strong> 记录结束Lazy Persist持久化操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">recordEndLazyPersist</span><span class="params">(</span></span></div><div class="line">    <span class="keyword">final</span> String bpid, <span class="keyword">final</span> <span class="keyword">long</span> blockId, <span class="keyword">final</span> File[] savedFiles) &#123;</div><div class="line">  Map&lt;Long, RamDiskReplicaLru&gt; map = replicaMaps.get(bpid);</div><div class="line">  RamDiskReplicaLru ramDiskReplicaLru = map.get(blockId);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (ramDiskReplicaLru == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown replica bpid="</span> +</div><div class="line">        bpid + <span class="string">"; blockId="</span> + blockId);</div><div class="line">  &#125;</div><div class="line">  ramDiskReplicaLru.recordSavedBlockFiles(savedFiles);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (replicasNotPersisted.peek() == ramDiskReplicaLru) &#123;</div><div class="line">    <span class="comment">// Common case.</span></div><div class="line">    replicasNotPersisted.remove();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Caller error? Fallback to O(n) removal.</span></div><div class="line">    replicasNotPersisted.remove(ramDiskReplicaLru);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ramDiskReplicaLru.lastUsedTime = Time.monotonicNow();</div><div class="line">  replicasPersisted.put(ramDiskReplicaLru.lastUsedTime, ramDiskReplicaLru);</div><div class="line">  ramDiskReplicaLru.isPersisted = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>reenqueueReplicaNotPersisted</strong> 持久化失败，则将该副本重新加入replicasNotPersisted队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reenqueueReplicaNotPersisted</span><span class="params">(<span class="keyword">final</span> RamDiskReplica ramDiskReplicaLru)</span> </span>&#123;</div><div class="line">  replicasNotPersisted.add((RamDiskReplicaLru) ramDiskReplicaLru);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div align="center"><br> <img src="http://img.blog.csdn.net/20160529195802001" width="800" height="350" alt="图4" align="center"><br></div><br><div align="center"><br> 图四<br></div>

<p>而这些方法大概的执行顺序如图四所示</p>
<p>当节点重启或者有新的文件被设置了LAZY_PERSIST策略后,就会有新的副本块被存储到内存中,同时会加入到replicaNotPersisted队列中.然后经过中间的dequeueNextReplicaToPersist取出下一个将被持久化的副本块,进行写磁盘的操作.recordStartLazyPersist,recordEndLazyPersist这2个方法会在持久化的过程中被调用,标志着持久化状态的变更.</p>
<p>还有三个方法虽然与持久化无关，但是也比较重要</p>
<ul>
<li><p><strong>discardReplica</strong>:当此副本已经被检测出不需要的时候,包括已被删除,或已损坏的情况,可以从内存中移除,撤销.</p>
</li>
<li><p><strong>touch</strong>:恰好与Linux种的touch同名,此方法意味访问了一次某特定的副本块,并会更新此副本块的lastUesdTime. lastUesdTime会在后面提到的LRU算法中起到关键的作用.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//touch会更新最近访问的时间</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">touch</span><span class="params">(<span class="keyword">final</span> String bpid,</span></span></div><div class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> blockId) &#123;</div><div class="line">  Map&lt;Long, RamDiskReplicaLru&gt; map = replicaMaps.get(bpid);</div><div class="line">  RamDiskReplicaLru ramDiskReplicaLru = map.get(blockId);</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// Reinsert the replica with its new timestamp.</span></div><div class="line">  <span class="comment">// 更新最近访问时间戳,并重新插入数据</span></div><div class="line">  <span class="keyword">if</span> (replicasPersisted.remove(ramDiskReplicaLru.lastUsedTime, ramDiskReplicaLru)) &#123;</div><div class="line">    ramDiskReplicaLru.lastUsedTime = Time.monotonicNow();</div><div class="line">    replicasPersisted.put(ramDiskReplicaLru.lastUsedTime, ramDiskReplicaLru);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第二步获取候选移除块</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> RamDiskReplicaLru <span class="title">getNextCandidateForEviction</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 获取replicasPersisted迭代器进行遍历</span></div><div class="line">  <span class="keyword">final</span> Iterator&lt;RamDiskReplicaLru&gt; it = replicasPersisted.values().iterator();</div><div class="line">  <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">    <span class="comment">// 因为replicasPersisted已经根据时间排好序了,所以取出当前的块进行移除即可</span></div><div class="line">    <span class="keyword">final</span> RamDiskReplicaLru ramDiskReplicaLru = it.next();</div><div class="line">    it.remove();</div><div class="line"></div><div class="line">    Map&lt;Long, RamDiskReplicaLru&gt; replicaMap =</div><div class="line">        replicaMaps.get(ramDiskReplicaLru.getBlockPoolId());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (replicaMap != <span class="keyword">null</span> &amp;&amp; replicaMap.get(ramDiskReplicaLru.getBlockId()) != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> ramDiskReplicaLru;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// The replica no longer exists, look for the next one.</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>getNextCandidateForEviction</strong>:此方法在DataNode内存空间不足,需要内存额外预留出空间给新的副本块存放时被调用.此方法会根据所设置的eviction scheme模式,选择需要被移除的块,默认的是LRU策略的.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Attempt to evict one or more transient block replicas until we</div><div class="line"> * have at least bytesNeeded bytes free.</div><div class="line"> */</div><div class="line"><span class="comment">//根据已持久化的块的访问时间来进行筛选移除,而不是直接是内存中的块</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictBlocks</span><span class="params">(<span class="keyword">long</span> bytesNeeded)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">int</span> iterations = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">final</span> <span class="keyword">long</span> cacheCapacity = cacheManager.getCacheCapacity();</div><div class="line">  <span class="comment">// 当检测到内存空间不满足外界需要的大小时</span></div><div class="line">  <span class="keyword">while</span> (iterations++ &lt; MAX_BLOCK_EVICTIONS_PER_ITERATION &amp;&amp;</div><div class="line">         (cacheCapacity - cacheManager.getCacheUsed()) &lt; bytesNeeded) &#123;</div><div class="line">    <span class="comment">// 获取待移除副本信息</span></div><div class="line">    RamDiskReplica replicaState = ramDiskReplicaTracker.getNextCandidateForEviction();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (replicaState == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">      LOG.debug(<span class="string">"Evicting block "</span> + replicaState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">// 移除内存中的相关块并释放空间</span></div><div class="line">      <span class="comment">// Delete the block+meta files from RAM disk and release locked</span></div><div class="line">      <span class="comment">// memory.</span></div><div class="line">      removeOldReplica(replicaInfo, newReplicaInfo, blockFile, metaFile,</div><div class="line">          blockFileUsed, metaFileUsed, bpid);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LazyWriter"><a href="#LazyWriter" class="headerlink" title="LazyWriter"></a>LazyWriter</h2><p>LazyWriter是一个线程服务,他是一个发动机,循环不断的从队列中取出待持久化的数据块,提交到异步持久化服务中去.直接来看主要的run方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> numSuccessiveFailures = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (fsRunning &amp;&amp; shouldRun) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// 取出新的副本块并提交到异步服务中,返回是否提交成功布尔值</span></div><div class="line">      numSuccessiveFailures = saveNextReplica() ? <span class="number">0</span> : (numSuccessiveFailures + <span class="number">1</span>);</div><div class="line"></div><div class="line">      <span class="comment">// Sleep if we have no more work to do or if it looks like we are not</span></div><div class="line">      <span class="comment">// making any forward progress. This is to ensure that if all persist</span></div><div class="line">      <span class="comment">// operations are failing we don't keep retrying them in a tight loop.</span></div><div class="line">      <span class="keyword">if</span> (numSuccessiveFailures &gt;= ramDiskReplicaTracker.numReplicasNotPersisted()) &#123;</div><div class="line">        Thread.sleep(checkpointerInterval * <span class="number">1000</span>);</div><div class="line">        numSuccessiveFailures = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      LOG.info(<span class="string">"LazyWriter was interrupted, exiting"</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      LOG.warn(<span class="string">"Ignoring exception in LazyWriter:"</span>, e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进入saveNextReplica方法的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">saveNextReplica</span><span class="params">()</span> </span>&#123;</div><div class="line">  RamDiskReplica block = <span class="keyword">null</span>;</div><div class="line">  FsVolumeReference targetReference;</div><div class="line">  FsVolumeImpl targetVolume;</div><div class="line">  ReplicaInfo replicaInfo;</div><div class="line">  <span class="keyword">boolean</span> succeeded = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 从队列种取出新的待持久化的块</span></div><div class="line">    block = ramDiskReplicaTracker.dequeueNextReplicaToPersist();</div><div class="line">    <span class="keyword">if</span> (block != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (FsDatasetImpl.<span class="keyword">this</span>) &#123;</div><div class="line">        ...</div><div class="line">        <span class="comment">// 提交到异步服务中去</span></div><div class="line">          asyncLazyPersistService.submitLazyPersistTask(</div><div class="line">              block.getBlockPoolId(), block.getBlockId(),</div><div class="line">              replicaInfo.getGenerationStamp(), block.getCreationTime(),</div><div class="line">              replicaInfo.getMetaFile(), replicaInfo.getBlockFile(),</div><div class="line">              targetReference);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    succeeded = <span class="keyword">true</span>;</div><div class="line">  &#125; <span class="keyword">catch</span>(IOException ioe) &#123;</div><div class="line">    LOG.warn(<span class="string">"Exception saving replica "</span> + block, ioe);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!succeeded &amp;&amp; block != <span class="keyword">null</span>) &#123;</div><div class="line">      LOG.warn(<span class="string">"Failed to save replica "</span> + block + <span class="string">". re-enqueueing it."</span>);</div><div class="line">      onFailLazyPersist(block.getBlockPoolId(), block.getBlockId());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> succeeded;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div align="center"><br> <img src="http://img.blog.csdn.net/20160529200024759" width="800" height="350" alt="图5" align="center"><br></div><br><div align="center"><br> 图五<br></div>

<p>所以LazyWriter线程服务的流程图可以归纳为如图四所示:</p>
<h2 id="RamDiskAsyncLazyPersistService"><a href="#RamDiskAsyncLazyPersistService" class="headerlink" title="RamDiskAsyncLazyPersistService"></a>RamDiskAsyncLazyPersistService</h2><p>RamDiskAsyncLazyPersistService主要围绕着Volume磁盘和Executor线程池这2部分的内容.秉持着下面一个原则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一个磁盘服务对应一个线程池,并且一个线程池的最大线程数也只有1个.</div></pre></td></tr></table></figure>
<p>线程池列表定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RamDiskAsyncLazyPersistService</span> </span>&#123;</div><div class="line">...</div><div class="line">  <span class="keyword">private</span> Map&lt;File, ThreadPoolExecutor&gt; executors</div><div class="line">      = <span class="keyword">new</span> HashMap&lt;File, ThreadPoolExecutor&gt;();</div><div class="line">...</div></pre></td></tr></table></figure>
<p>当服务启动的时候,就会有新的磁盘目录加入.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addVolume</span><span class="params">(File volume)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (executors == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"AsyncLazyPersistService is already shutdown"</span>);</div><div class="line">  &#125;</div><div class="line">  ThreadPoolExecutor executor = executors.get(volume);</div><div class="line">  <span class="comment">// 如果当前已存在此磁盘目录对应的线程池,则跑异常</span></div><div class="line">  <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Volume "</span> + volume + <span class="string">" is already existed."</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 否则进行添加</span></div><div class="line">  addExecutorForVolume(volume);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进入addExecutorForVolume方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addExecutorForVolume</span><span class="params">(<span class="keyword">final</span> File volume)</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="comment">// 新建线程池,最大线程执行数为</span></div><div class="line">  ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">      CORE_THREADS_PER_VOLUME, MAXIMUM_THREADS_PER_VOLUME,</div><div class="line">      THREADS_KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</div><div class="line">      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);</div><div class="line"></div><div class="line">  <span class="comment">// This can reduce the number of running threads</span></div><div class="line">  executor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</div><div class="line">  <span class="comment">// 加入到executors中,以为volume作为key</span></div><div class="line">  executors.put(volume, executor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一个需要注意的是提交执行方法<strong>submitLazyPersistTask</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">submitLazyPersistTask</span><span class="params">(String bpId, <span class="keyword">long</span> blockId,</span></span></div><div class="line">    <span class="keyword">long</span> genStamp, <span class="keyword">long</span> creationTime,</div><div class="line">    File metaFile, File blockFile,</div><div class="line">    FsVolumeReference target) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">    LOG.debug(<span class="string">"LazyWriter schedule async task to persist RamDisk block pool id: "</span></div><div class="line">        + bpId + <span class="string">" block id: "</span> + blockId);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 获取需要持久化到目标磁盘实例</span></div><div class="line">  FsVolumeImpl volume = (FsVolumeImpl)target.getVolume();</div><div class="line">  File lazyPersistDir  = volume.getLazyPersistDir(bpId);</div><div class="line">  <span class="keyword">if</span> (!lazyPersistDir.exists() &amp;&amp; !lazyPersistDir.mkdirs()) &#123;</div><div class="line">    FsDatasetImpl.LOG.warn(<span class="string">"LazyWriter failed to create "</span> + lazyPersistDir);</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"LazyWriter fail to find or create lazy persist dir: "</span></div><div class="line">        + lazyPersistDir.toString());</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 新建此服务Task</span></div><div class="line">  ReplicaLazyPersistTask lazyPersistTask = <span class="keyword">new</span> ReplicaLazyPersistTask(</div><div class="line">      bpId, blockId, genStamp, creationTime, blockFile, metaFile,</div><div class="line">      target, lazyPersistDir);</div><div class="line">  <span class="comment">// 提交到对应volume的线程池中执行</span></div><div class="line">  execute(volume.getCurrentDir(), lazyPersistTask);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在上述执行的过程中发生失败,会调用失败处理的方法,并会重新将此副本块插入到replicateNotPersisted队列等待下一次的持久化.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailLazyPersist</span><span class="params">(String bpId, <span class="keyword">long</span> blockId)</span> </span>&#123;</div><div class="line">  RamDiskReplica block = <span class="keyword">null</span>;</div><div class="line">  block = ramDiskReplicaTracker.getReplica(bpId, blockId);</div><div class="line">  <span class="keyword">if</span> (block != <span class="keyword">null</span>) &#123;</div><div class="line">    LOG.warn(<span class="string">"Failed to save replica "</span> + block + <span class="string">". re-enqueueing it."</span>);</div><div class="line">    <span class="comment">// 重新插入队列操作</span></div><div class="line">    ramDiskReplicaTracker.reenqueueReplicaNotPersisted(block);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div align="center"><br> <img src="http://img.blog.csdn.net/20160529200337300" width="800" height="350" alt="图6" align="center"><br></div><br><div align="center"><br> 图六<br></div>

<p>RamDiskAsyncLazyPersistService总的结构图图图5所示。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="安装RAM磁盘"><a href="#安装RAM磁盘" class="headerlink" title="安装RAM磁盘"></a>安装RAM磁盘</h2><p>使用Unix mount命令安装RAM磁盘分区。 例如。 在/ mnt / dn-tmpfs /下安装32 GB tmpfs分区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mount -t tmpfs -o size = 32g tmpfs / mnt / dn-tmpfs /</div></pre></td></tr></table></figure>
<p>建议您在/ etc / fstab中创建一个条目，以便在节点重新启动时自动重新创建RAM磁盘。 另一个选项是使用/ dev / shm下的子目录，它是默认情况下在大多数Linux发行版上可用的tmpfs安装。 确保安装的大小大于或等于您的dfs.datanode.max.locked.memory设置，否则在/ etc / fstab中重写它。 不建议对每个数据节点使用多个tmpfs分区进行Lazy Persist写入。</p>
<h2 id="使用RAM-DISK存储类型标记tmpfs卷"><a href="#使用RAM-DISK存储类型标记tmpfs卷" class="headerlink" title="使用RAM_DISK存储类型标记tmpfs卷"></a>使用RAM_DISK存储类型标记tmpfs卷</h2><p>通过hdfs-site.xml中的dfs.datanode.data.dir配置设置将tmpfs目录标记为RAM_DISK存储类型。 例如。 在具有三个硬盘卷/ grid / 0，/ grid / 1和/ grid / 2和tmpfs mount / mnt / dn-tmpfs的数据节点上，必须按如下所示设置dfs.datanode.data.dir：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>/grid/0,/grid/1,/grid/2,[RAM_DISK]/mnt/dn-tmpfs<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这一步是至关重要的。 如果没有RAM_DISK标记，HDFS会将tmpfs卷视为非易失性存储，并且数据不会保存到永久存储。 您将在节点重新启动时丢失数据。</p>
<h2 id="启用存储策略"><a href="#启用存储策略" class="headerlink" title="启用存储策略"></a>启用存储策略</h2><p>使用上面提到的LAZY_PERSIST,而不是使用默认的StoragePolicy.DEFAULT,默认策略的存储介质是DISK类型的.设置存储策略的方法目前有2种:</p>
<ul>
<li>第一种,通过命令行的方式,调用如下命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hdfs storagepolicies -setStoragePolicy -path &lt;path&gt; -policy LAZY_PERSIST</div></pre></td></tr></table></figure>
<ul>
<li>第二种,通过调用对应的程序方法,比如调用暴露到外部的create文件方法,但是得带上参数CreateFlag.LAZY_PERSIST.例子如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FSDataOutputStream fos =</div><div class="line">        fs.create(</div><div class="line">            path,</div><div class="line">            FsPermission.getFileDefault(),</div><div class="line">            EnumSet.of(CreateFlag.CREATE, CreateFlag.LAZY_PERSIST),</div><div class="line">            bufferLength,</div><div class="line">            replicationFactor,</div><div class="line">            blockSize,</div><div class="line">            <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/MemoryStorage.html" title="Memory Storage Support in HDFS" target="_blank" rel="external">Memory Storage Support in HDFS</a></li>
<li><a href="http://blog.csdn.net/androidlushangderen/article/details/51514216" title="HDFS内存存储" target="_blank" rel="external">HDFS内存存储 - 走在前往架构师的路上 - CSDN博客</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/08/maven_conflict/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="韩思明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Han 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/08/maven_conflict/" itemprop="url">Maven依赖冲突解决</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T20:15:43+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/maven/" itemprop="url" rel="index">
                    <span itemprop="name">maven</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在部署一个spring-boot项目到远程测试机上的tomcat之后，发现tomcat并没有启动起来，让我折腾了近2个小时，现在将解决思路以及解决方法记录下来，下次在遇到Maven依赖冲突之后，能够很快的解决。</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><h2 id="查看tomcat日志"><a href="#查看tomcat日志" class="headerlink" title="查看tomcat日志"></a>查看tomcat日志</h2><p>因为tomcat启动失败，所以首先查看tomcat打印出来的相关日志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail -n 500 &#123;TOMCAT_HOME&#125;/logs/catalina.2017-08-08.log</div></pre></td></tr></table></figure>
<p>里面确实有错误日志，其中这个错误日志引起的我的注意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Caused by: java.lang.IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath. Either remove Logback or the competing implementation (class org.slf4j.impl.Log4jLoggerFactory loaded from file:/export/App/apache-tomcat-8.5.16/webapps/k8s-api/WEB-INF/lib/slf4j-log4j12-1.7.5.jar). If you are using WebLogic you will need to add &apos;org.slf4j&apos; to prefer-application-packages in WEB-INF/weblogic.xml Object of class [org.slf4j.impl.Log4jLoggerFactory] must be an instance of class ch.qos.logback.classic.LoggerContext</div><div class="line">	at org.springframework.util.Assert.isInstanceOf(Assert.java:346)</div><div class="line">	at org.springframework.boot.logging.logback.LogbackLoggingSystem.getLoggerContext(LogbackLoggingSystem.java:221)</div><div class="line">	at org.springframework.boot.logging.logback.LogbackLoggingSystem.getLogger(LogbackLoggingSystem.java:213)</div><div class="line">	at org.springframework.boot.logging.logback.LogbackLoggingSystem.beforeInitialize(LogbackLoggingSystem.java:98)</div><div class="line">	at org.springframework.boot.logging.LoggingApplicationListener.onApplicationStartedEvent(LoggingApplicationListener.java:216)</div><div class="line">	at org.springframework.boot.logging.LoggingApplicationListener.onApplicationEvent(LoggingApplicationListener.java:198)</div><div class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:163)</div><div class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:136)</div><div class="line">	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:119)</div><div class="line">	at org.springframework.boot.context.event.EventPublishingRunListener.publishEvent(EventPublishingRunListener.java:111)</div><div class="line">	at org.springframework.boot.context.event.EventPublishingRunListener.started(EventPublishingRunListener.java:60)</div><div class="line">	at org.springframework.boot.SpringApplicationRunListeners.started(SpringApplicationRunListeners.java:48)</div><div class="line">	at org.springframework.boot.SpringApplication.run(SpringApplication.java:303)</div><div class="line">	at org.springframework.boot.context.web.SpringBootServletInitializer.run(SpringBootServletInitializer.java:149)</div><div class="line">	at org.springframework.boot.context.web.SpringBootServletInitializer.createRootApplicationContext(SpringBootServletInitializer.java:129)</div><div class="line">	at org.springframework.boot.context.web.SpringBootServletInitializer.onStartup(SpringBootServletInitializer.java:85)</div><div class="line">	at org.springframework.web.SpringServletContainerInitializer.onStartup(SpringServletContainerInitializer.java:175)</div><div class="line">	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5196)</div><div class="line">	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)</div><div class="line">	... 10 more</div></pre></td></tr></table></figure>
<p>关键的信息在这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LoggerFactory is not a Logback LoggerContext but Logback is on the classpath. Either remove Logback or the competing implementation (class org.slf4j.impl.Log4jLoggerFactory loaded from file:/export/App/apache-tomcat-8.5.16/webapps/k8s-api/WEB-INF/lib/slf4j-log4j12-1.7.5.jar).</div></pre></td></tr></table></figure>
<p>大概就是说<strong>Logback</strong>已经在<strong>classpath</strong>中存在，这时候就应该意识到有<strong>Logback</strong>依赖冲突，在多个地方都有Logback的依赖。</p>
<p>我的pom.xml文件如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      ...</div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="使用maven命令，查看依赖树"><a href="#使用maven命令，查看依赖树" class="headerlink" title="使用maven命令，查看依赖树"></a>使用maven命令，查看依赖树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn dependency:tree</div></pre></td></tr></table></figure>
<p>查看结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[INFO] +- org.springframework.boot:spring-boot-starter:jar:1.3.3.RELEASE:compile</div><div class="line">[INFO] |  +- org.springframework.boot:spring-boot:jar:1.3.3.RELEASE:compile</div><div class="line">[INFO] |  +- org.springframework.boot:spring-boot-autoconfigure:jar:1.3.3.RELEASE:compile</div><div class="line">[INFO] |  +- org.springframework.boot:spring-boot-starter-logging:jar:1.3.3.RELEASE:compile</div><div class="line">[INFO] |  |  +- ch.qos.logback:logback-classic:jar:1.1.5:compile</div><div class="line">[INFO] |  |  |  \- ch.qos.logback:logback-core:jar:1.1.5:compile</div><div class="line">[INFO] |  |  +- org.slf4j:jcl-over-slf4j:jar:1.7.5:compile</div><div class="line">[INFO] |  |  +- org.slf4j:jul-to-slf4j:jar:1.7.5:compile</div><div class="line">[INFO] |  |  \- org.slf4j:log4j-over-slf4j:jar:1.7.5:compile</div><div class="line">[INFO] |  +- org.springframework:spring-core:jar:4.2.5.RELEASE:compile</div><div class="line">[INFO] |  \- org.yaml:snakeyaml:jar:1.16:compile</div><div class="line">...</div><div class="line">[INFO] +- org.slf4j:slf4j-log4j12:jar:1.7.5:compile</div><div class="line">[INFO] |  \- org.slf4j:slf4j-api:jar:1.7.5:compile</div></pre></td></tr></table></figure>
<p>可以从上面的结果中很清楚的看见org.slf4j:log4j-over-slf4j:jar:1.7.5这个包冲突了，所以我们只需要去掉其中一个Logback的依赖即可。</p>
<h2 id="解决依赖冲突"><a href="#解决依赖冲突" class="headerlink" title="解决依赖冲突"></a>解决依赖冲突</h2><p>如下方法可以去掉多余的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">             <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">             <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>再重新启动tomcat，成功。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>在执行mvn的命令，如update，install之前，必须要先clean一下，否则可能会有之前的依赖还保留在里面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/HDFS Federation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="韩思明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Han 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/HDFS Federation/" itemprop="url">HDFS Federation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T20:23:55+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hdfs/" itemprop="url" rel="index">
                    <span itemprop="name">hdfs</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><div align="center"><br> <img src="https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-hdfs/images/federation-background.gif" width="500" height="350" alt="图1" align="center"><br></div><br><div align="center"><br> 图一<br></div>

<ul>
<li><strong>Namespace</strong> 管理目录，文件和数据块。它支持常见的文件系统操作，如创建文件，修改文件，删除文件等。</li>
<li><strong>Block Storage</strong> 由两部分组成：<strong>Block Management</strong>维护集群中datanode的基本关系，它支持数据块相关的操作，如：创建数据块，删除数据块等，同时，它也会管理副本的复制和存放。<strong>Physical Storage</strong>存储实际的数据块并提供针对数据块的读写服务。</li>
</ul>
<p>以前的HDFS架构只允许一个集群拥有一个命名空间，一个Namenode管理着整个命名空间。HDFS Federation通过向HDFS增加多Namenode和namespace来解决这种限制。</p>
<h1 id="HDFS-Federation"><a href="#HDFS-Federation" class="headerlink" title="HDFS Federation"></a>HDFS Federation</h1><blockquote>
<p>HDFS Federation是Hadoop最新发布版本Hadoop-0.23.0中为解决HDFS单点故障而提出的namenode水平扩展方案。该方案允许HDFS创建多个namespace以提高集群的扩展性和隔离性。本篇文章主要介绍了HDFS Federation的设计动机和基本原理。</p>
</blockquote>
<div align="center"><br> <img src="https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-hdfs/images/federation.gif" width="550" height="350" alt="图1" align="center"><br></div><br><div align="center"><br> 图二<br></div>

<p>为了水平扩展name service，Federation使用了独立的多Namenode/Namespaces的架构。这些namenode之间是联合的，也就是说，他们之间相互独立且不需要互相协调，各自分工，管理自己的区域。（The Namenodes are federated; the Namenodes are independent and do not require coordination with each other.）Datanode被用作是存储设备，在集群中，每一个Datanode都在Namenodes上注册。Datanodes周期性的发送心跳包和关于块的报告。Datanodes也要处理来自Namenodes的命令。</p>
<h2 id="几个关键的概念"><a href="#几个关键的概念" class="headerlink" title="几个关键的概念"></a>几个关键的概念</h2><ul>
<li><strong>Block Pool</strong> 块池，一个Block Pool是属于同一个namespace下的一组块集合。每个datanode可能会存储集群中所有Block Pool的数据块。（Datanodes store blocks for all the block pools in the cluster.）每个Block Pool的管理是独立的。这样的好处是，允许一个namespace为一个新的块生成一个Block IDs，而不需要和其他的namespace进行协调。一个namenode挂掉了，不会影响其他namenode。</li>
<li><strong>Namespace Volume</strong> 一个namespace和它的Block Pool一起被统称为Namespace Volume。它是管理的最小单元。当一个Namenode/namespace被删除之后，每个Datanode上相应的Block Pool也会被删除。每个Namespace Volume是升级的最小的一个单元。</li>
<li><strong>ClusterID</strong> 一个新的标识ClusterID添加到集群，用来标记所有的Nodes，当Namenode格式化时(formated)，将会自动创建ClusterID，这个ID用来区分集群中的Namenodes。</li>
</ul>
<h2 id="Namespace的管理"><a href="#Namespace的管理" class="headerlink" title="Namespace的管理"></a>Namespace的管理</h2><div align="center"><br> <img src="http://dongxicheng.org/wp-content/uploads/2011/12/client-side-mount-table.jpg" width="400" height="250" alt="图1" align="center"><br></div><br><div align="center"><br> 图三<br></div>

<p>Federation中存在多个命名空间，如何划分和管理这些命名空间非常关键。在Federation中并采用“文件名hash”的方法，因为该方法的locality非常差，比如：查看某个目录下面的文件，如果采用文件名hash的方法存放文件，则这些文件可能被放到不同namespace中，HDFS需要访问所有namespace，代价过大。为了方便管理多个命名空间，HDFS Federation采用了经典的Client Side Mount Table。</p>
<p>如图三所示，下面四个深色三角形代表一个独立的命名空间，上方浅色的三角形代表从客户角度去访问的子命名空间。各个深色的命名空间Mount到浅色的表中，客户可以访问不同的挂载点来访问不同的命名空间，这就如同在Linux系统中访问不同挂载点一样。这就是HDFS Federation中命名空间管理的基本原理：将各个命名空间挂载到全局mount-table中，就可以做将数据到全局共享；同样的命名空间挂载到个人的mount-table中，这就成为应用程序可见的命名空间视图。</p>
<h2 id="HDFS-Federation的优势"><a href="#HDFS-Federation的优势" class="headerlink" title="HDFS Federation的优势"></a>HDFS Federation的优势</h2><ul>
<li><strong>命名空间的扩展.</strong>因为随着集群使用时间的加长,HDFS上存放的数据也将会越来越多.这个时候如果还是将所有的数据都往一个NameNode上存放,这个文件系统会显得非常的庞大.这时候我们可以进行横向扩展,把一些大的目录分离出去.使得每个NameNode下的数据看起来更加的精简。</li>
<li><strong>性能的提升.</strong>这个也很好理解.当NameNode所持有的数据量达到了一个非常大规模的量级的时候(比如超过1亿个文件),这个时候NameNode的处理效率可能就会有影响,它可能比较容易的会陷入一个繁忙的状态.而整个集群将会受限于一个单点NameNode的处理效率,从而影响集群整体的吞吐量.这个时候多NameNode机制显然可以减轻很多这部分的压力。</li>
<li><strong>资源的隔离.</strong>这一点考虑的就比较深了.通过多个命名空间,我们可以将关键数据文件目录移到不同的NameNode上,以此不让这些关键数据的读写操作受到其他普通文件读写操作的影响.也就是说这些NameNode将会只处理特定的关键的任务所发来的请求,而屏蔽了其他普通任务的文件读写请求,以此做到了资源的隔离.千万不要小看这一点,当你发现NameNode正在处理某个不良任务的大规模的请求操作导致响应速度极慢时,你一定会非常的懊恼。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-hdfs/Federation.html" title="Apache Hadoop 2.7.2 – HDFS Federation" target="_blank" rel="external">https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-hdfs/Federation.html</a></li>
<li><a href="http://dongxicheng.org/mapreduce/hdfs-federation-introduction/" title="董的博客 » HDFS Federation设计动机与基本原理" target="_blank" rel="external">http://dongxicheng.org/mapreduce/hdfs-federation-introduction/</a></li>
<li><a href="http://blog.csdn.net/androidlushangderen/article/details/52135506" title="HDFS Federation机制 - 走在前往架构师的路上" target="_blank" rel="external">http://blog.csdn.net/androidlushangderen/article/details/52135506</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="韩思明" />
          <p class="site-author-name" itemprop="name">韩思明</p>
           
              <p class="site-description motion-element" itemprop="description">专注于大数据，云计算，Java后端</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hansiming" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">韩思明</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
