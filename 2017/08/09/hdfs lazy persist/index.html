<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="hdfs," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="介绍  图一  HDFS支持由Data Node管理的写入到堆栈内存的功能。Data Node会异步的将数据从内存持久化至磁盘，从而在性能敏感的IO Path中移去昂贵的磁盘IO和校验，因此我们称之为Lazy Persist。HDFS尽可能的保证在Lazy Persist策略下的持久性。在副本还未持久化至磁盘，节点重启了，则有可能会发生罕见的数据遗失。我们可以选择Lazy Persist Writ">
<meta name="keywords" content="hdfs">
<meta property="og:type" content="article">
<meta property="og:title" content="HDFS内存存储原理（Lazy Persist）">
<meta property="og:url" content="http://yoursite.com/2017/08/09/hdfs lazy persist/index.html">
<meta property="og:site_name" content="Han 博客">
<meta property="og:description" content="介绍  图一  HDFS支持由Data Node管理的写入到堆栈内存的功能。Data Node会异步的将数据从内存持久化至磁盘，从而在性能敏感的IO Path中移去昂贵的磁盘IO和校验，因此我们称之为Lazy Persist。HDFS尽可能的保证在Lazy Persist策略下的持久性。在副本还未持久化至磁盘，节点重启了，则有可能会发生罕见的数据遗失。我们可以选择Lazy Persist Writ">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/images/LazyPersistWrites.png">
<meta property="og:image" content="http://img.blog.csdn.net/20160529195437234">
<meta property="og:image" content="http://img.blog.csdn.net/20160529195555378">
<meta property="og:image" content="http://img.blog.csdn.net/20160529195802001">
<meta property="og:image" content="http://img.blog.csdn.net/20160529200024759">
<meta property="og:image" content="http://img.blog.csdn.net/20160529200337300">
<meta property="og:updated_time" content="2017-08-10T02:01:26.338Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HDFS内存存储原理（Lazy Persist）">
<meta name="twitter:description" content="介绍  图一  HDFS支持由Data Node管理的写入到堆栈内存的功能。Data Node会异步的将数据从内存持久化至磁盘，从而在性能敏感的IO Path中移去昂贵的磁盘IO和校验，因此我们称之为Lazy Persist。HDFS尽可能的保证在Lazy Persist策略下的持久性。在副本还未持久化至磁盘，节点重启了，则有可能会发生罕见的数据遗失。我们可以选择Lazy Persist Writ">
<meta name="twitter:image" content="https://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/images/LazyPersistWrites.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/09/hdfs lazy persist/"/>





  <title>HDFS内存存储原理（Lazy Persist） | Han 博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?61353e23b8e42a3b785fab01ab47ccba";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Han 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/09/hdfs lazy persist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="韩思明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Han 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">HDFS内存存储原理（Lazy Persist）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T20:23:55+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hdfs/" itemprop="url" rel="index">
                    <span itemprop="name">hdfs</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><div align="center"><br> <img src="https://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/images/LazyPersistWrites.png" alt="图1" align="center"><br></div><br><div align="center"><br> 图一<br></div>

<p>HDFS支持由Data Node管理的写入到堆栈内存的功能。Data Node会异步的将数据从内存持久化至磁盘，从而在性能敏感的IO Path中移去昂贵的磁盘IO和校验，因此我们称之为Lazy Persist。HDFS尽可能的保证在Lazy Persist策略下的持久性。在副本还未持久化至磁盘，节点重启了，则有可能会发生罕见的数据遗失。我们可以选择Lazy Persist Writes的策略来减少延迟，但可能会损失一定的持久性。</p>
<p>上文描述的原理在图一的表示其实是<strong>4,6</strong>的步骤.写数据的RAM,然后异步的写到Disk.前面几个步骤是如何设置StorageType的操作,这个在下文种会具体提到.所以上图所示的大体步骤可以归纳为如下:</p>
<ol>
<li>对目标文件目录设置StoragePolicy为LAZY_PERSIST的内存存储策略.</li>
<li>客户端进程向NameNode发起创建/写文件的请求.</li>
<li>请求到具体的DataNode,DataNode会把这些数据块写入RAM内存中,同时启动异步线程服务将内存数据持久化到磁盘上.</li>
</ol>
<p>内存的异步持久化存储,就是明显不同于其他介质存储数据的地方.这应该也是LAZY_PERSIST的名称的源由吧,数据不是马上落盘,而是”lazy persisit”懒惰的方式,延时的处理.</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>在之前的篇幅中已经提到过,数据存储的同时会有另外一批数据会被异步的持久化,所以这里一定会涉及到多个服务对象的合作.这些服务对象的指挥者是FsDatasetImpl.他是一个掌管DataNode所有磁盘读写数据的管家.</p>
<p>在FsDatasetImpl中,与内存存储相关的服务对象有如下的3个.</p>
<div align="center"><br> <img src="http://img.blog.csdn.net/20160529195437234" width="800" height="350" alt="图2" align="center"><br></div><br><div align="center"><br> 图二<br></div>

<ul>
<li><p><strong>LazyWriter</strong>:lazyWriter是一个线程服务,此线程会不断的循环着从数据块列表中取出数据块,加入到异步持久化线程池RamDiskAsyncLazyPersistService中去执行.</p>
</li>
<li><p><strong>RamDiskAsyncLazyPersistService</strong>:此对象就是异步持久化线程服务,里面针对每一个磁盘块设置一个对应的线程池,然后需要持久化到给定的磁盘块的数据块会被提交到对应的线程池中去.每个线程池的最大线程数为1.</p>
</li>
<li><p><strong>RamDiskReplicaLruTracker</strong>:副本块跟踪类,此类种维护了所有已持久化,未持久化的副本以及总副本数据信息.所以当一个副本被最终存储到内存种后,相应的会有副本所属队列信息的变更.其次当节点内存不足的时候,部分距离最近最久没有被访问的副本块会在此类中被移除.</p>
</li>
</ul>
<h2 id="RamDiskReplicaLruTracker"><a href="#RamDiskReplicaLruTracker" class="headerlink" title="RamDiskReplicaLruTracker"></a>RamDiskReplicaLruTracker</h2><p>在以上3者中,RamDiskReplicaLruTracker的角色起到了一个中间人的角色.因为他内部维护了多个关系的数据块信息.主要的就是以下3类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RamDiskReplicaLruTracker</span> <span class="keyword">extends</span> <span class="title">RamDiskReplicaTracker</span> </span>&#123;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * &lt;block pool ID &lt;block ID, RamDiskRelicaLru&gt;</div><div class="line">   * Map of blockpool ID to &lt;map of blockID to ReplicaInfo&gt;.</div><div class="line">   */</div><div class="line">  Map&lt;String, Map&lt;Long, RamDiskReplicaLru&gt;&gt; replicaMaps;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 将会被写入到磁盘的副本队列</div><div class="line">   * Queue of replicas that need to be written to disk.</div><div class="line">   * Stale entries are GC'd by dequeueNextReplicaToPersist.</div><div class="line">   */</div><div class="line">  Queue&lt;RamDiskReplicaLru&gt; replicasNotPersisted;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 已经被持久化的副本，按照上次使用的时间排序</div><div class="line">   * Map of persisted replicas ordered by their last use times.</div><div class="line">   */</div><div class="line">  TreeMultimap&lt;Long, RamDiskReplicaLru&gt; replicasPersisted;</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div align="center"><br> <img src="http://img.blog.csdn.net/20160529195555378" width="800" height="350" alt="图3" align="center"><br></div><br><div align="center"><br> 图三<br></div>

<p>三种数据块的关系如图三所示，replicaMaps是<block pool="" id="" <block="" id,="" ramdiskrelicalru="">的Map（关于Block pool，在上篇<a href="http://www.cszjo.com/2017/08/06/HDFS%20Federation/" target="_blank" rel="external">HDFS Federation</a>中有介绍），Ram副本都会在replicaMaps中存在。replicasNotPersisted保存的是将会写入到磁盘的队列。replicasPersisted保存的是已经被持久化的副本，并且按照上次使用的时间排序。</block></p>
<p>列出几个RamDiskReplicaLruTracker类中关键的方法</p>
<ul>
<li><strong>addReplica</strong> 新添副本</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addReplica</span><span class="params">(<span class="keyword">final</span> String bpid, <span class="keyword">final</span> <span class="keyword">long</span> blockId,</span></span></div><div class="line">                             <span class="keyword">final</span> FsVolumeImpl transientVolume) &#123;</div><div class="line">  Map&lt;Long, RamDiskReplicaLru&gt; map = replicaMaps.get(bpid);</div><div class="line">  <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;Long, RamDiskReplicaLru&gt;();</div><div class="line">    replicaMaps.put(bpid, map);</div><div class="line">  &#125;</div><div class="line">  RamDiskReplicaLru ramDiskReplicaLru = <span class="keyword">new</span> RamDiskReplicaLru(bpid, blockId, transientVolume);</div><div class="line">  map.put(blockId, ramDiskReplicaLru);</div><div class="line">  <span class="comment">//将ramDiskReplicaLru放入到replicasNotPersisted之中</span></div><div class="line">  replicasNotPersisted.add(ramDiskReplicaLru);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>dequeueNextReplicaToPersist</strong> 从replicasNotPersisted队列中拿出下一个将要被持久化的副本</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="comment">//从replicasNotPersisted中拿到下个将会被持久化的block</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> RamDiskReplicaLru <span class="title">dequeueNextReplicaToPersist</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">while</span> (replicasNotPersisted.size() != <span class="number">0</span>) &#123;</div><div class="line">    RamDiskReplicaLru ramDiskReplicaLru = replicasNotPersisted.remove();</div><div class="line">    Map&lt;Long, RamDiskReplicaLru&gt; replicaMap =</div><div class="line">        replicaMaps.get(ramDiskReplicaLru.getBlockPoolId());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (replicaMap != <span class="keyword">null</span> &amp;&amp; replicaMap.get(ramDiskReplicaLru.getBlockId()) != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> ramDiskReplicaLru;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// The replica no longer exists, look for the next one.</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>recordStartLazyPersist</strong> 记录开始Lazy Persist持久化操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">recordStartLazyPersist</span><span class="params">(</span></span></div><div class="line">     <span class="keyword">final</span> String bpid, <span class="keyword">final</span> <span class="keyword">long</span> blockId, FsVolumeImpl checkpointVolume) &#123;</div><div class="line">   Map&lt;Long, RamDiskReplicaLru&gt; map = replicaMaps.get(bpid);</div><div class="line">   RamDiskReplicaLru ramDiskReplicaLru = map.get(blockId);</div><div class="line"><span class="comment">//设置被持久化的Volume</span></div><div class="line">   ramDiskReplicaLru.setLazyPersistVolume(checkpointVolume);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>recordEndLazyPersist</strong> 记录结束Lazy Persist持久化操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">recordEndLazyPersist</span><span class="params">(</span></span></div><div class="line">    <span class="keyword">final</span> String bpid, <span class="keyword">final</span> <span class="keyword">long</span> blockId, <span class="keyword">final</span> File[] savedFiles) &#123;</div><div class="line">  Map&lt;Long, RamDiskReplicaLru&gt; map = replicaMaps.get(bpid);</div><div class="line">  RamDiskReplicaLru ramDiskReplicaLru = map.get(blockId);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (ramDiskReplicaLru == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown replica bpid="</span> +</div><div class="line">        bpid + <span class="string">"; blockId="</span> + blockId);</div><div class="line">  &#125;</div><div class="line">  ramDiskReplicaLru.recordSavedBlockFiles(savedFiles);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (replicasNotPersisted.peek() == ramDiskReplicaLru) &#123;</div><div class="line">    <span class="comment">// Common case.</span></div><div class="line">    replicasNotPersisted.remove();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Caller error? Fallback to O(n) removal.</span></div><div class="line">    replicasNotPersisted.remove(ramDiskReplicaLru);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ramDiskReplicaLru.lastUsedTime = Time.monotonicNow();</div><div class="line">  replicasPersisted.put(ramDiskReplicaLru.lastUsedTime, ramDiskReplicaLru);</div><div class="line">  ramDiskReplicaLru.isPersisted = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>reenqueueReplicaNotPersisted</strong> 持久化失败，则将该副本重新加入replicasNotPersisted队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reenqueueReplicaNotPersisted</span><span class="params">(<span class="keyword">final</span> RamDiskReplica ramDiskReplicaLru)</span> </span>&#123;</div><div class="line">  replicasNotPersisted.add((RamDiskReplicaLru) ramDiskReplicaLru);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div align="center"><br> <img src="http://img.blog.csdn.net/20160529195802001" width="800" height="350" alt="图4" align="center"><br></div><br><div align="center"><br> 图四<br></div>

<p>而这些方法大概的执行顺序如图四所示</p>
<p>当节点重启或者有新的文件被设置了LAZY_PERSIST策略后,就会有新的副本块被存储到内存中,同时会加入到replicaNotPersisted队列中.然后经过中间的dequeueNextReplicaToPersist取出下一个将被持久化的副本块,进行写磁盘的操作.recordStartLazyPersist,recordEndLazyPersist这2个方法会在持久化的过程中被调用,标志着持久化状态的变更.</p>
<p>还有三个方法虽然与持久化无关，但是也比较重要</p>
<ul>
<li><p><strong>discardReplica</strong>:当此副本已经被检测出不需要的时候,包括已被删除,或已损坏的情况,可以从内存中移除,撤销.</p>
</li>
<li><p><strong>touch</strong>:恰好与Linux种的touch同名,此方法意味访问了一次某特定的副本块,并会更新此副本块的lastUesdTime. lastUesdTime会在后面提到的LRU算法中起到关键的作用.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//touch会更新最近访问的时间</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">touch</span><span class="params">(<span class="keyword">final</span> String bpid,</span></span></div><div class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> blockId) &#123;</div><div class="line">  Map&lt;Long, RamDiskReplicaLru&gt; map = replicaMaps.get(bpid);</div><div class="line">  RamDiskReplicaLru ramDiskReplicaLru = map.get(blockId);</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// Reinsert the replica with its new timestamp.</span></div><div class="line">  <span class="comment">// 更新最近访问时间戳,并重新插入数据</span></div><div class="line">  <span class="keyword">if</span> (replicasPersisted.remove(ramDiskReplicaLru.lastUsedTime, ramDiskReplicaLru)) &#123;</div><div class="line">    ramDiskReplicaLru.lastUsedTime = Time.monotonicNow();</div><div class="line">    replicasPersisted.put(ramDiskReplicaLru.lastUsedTime, ramDiskReplicaLru);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第二步获取候选移除块</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> RamDiskReplicaLru <span class="title">getNextCandidateForEviction</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 获取replicasPersisted迭代器进行遍历</span></div><div class="line">  <span class="keyword">final</span> Iterator&lt;RamDiskReplicaLru&gt; it = replicasPersisted.values().iterator();</div><div class="line">  <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">    <span class="comment">// 因为replicasPersisted已经根据时间排好序了,所以取出当前的块进行移除即可</span></div><div class="line">    <span class="keyword">final</span> RamDiskReplicaLru ramDiskReplicaLru = it.next();</div><div class="line">    it.remove();</div><div class="line"></div><div class="line">    Map&lt;Long, RamDiskReplicaLru&gt; replicaMap =</div><div class="line">        replicaMaps.get(ramDiskReplicaLru.getBlockPoolId());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (replicaMap != <span class="keyword">null</span> &amp;&amp; replicaMap.get(ramDiskReplicaLru.getBlockId()) != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> ramDiskReplicaLru;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// The replica no longer exists, look for the next one.</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>getNextCandidateForEviction</strong>:此方法在DataNode内存空间不足,需要内存额外预留出空间给新的副本块存放时被调用.此方法会根据所设置的eviction scheme模式,选择需要被移除的块,默认的是LRU策略的.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Attempt to evict one or more transient block replicas until we</div><div class="line"> * have at least bytesNeeded bytes free.</div><div class="line"> */</div><div class="line"><span class="comment">//根据已持久化的块的访问时间来进行筛选移除,而不是直接是内存中的块</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictBlocks</span><span class="params">(<span class="keyword">long</span> bytesNeeded)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">int</span> iterations = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">final</span> <span class="keyword">long</span> cacheCapacity = cacheManager.getCacheCapacity();</div><div class="line">  <span class="comment">// 当检测到内存空间不满足外界需要的大小时</span></div><div class="line">  <span class="keyword">while</span> (iterations++ &lt; MAX_BLOCK_EVICTIONS_PER_ITERATION &amp;&amp;</div><div class="line">         (cacheCapacity - cacheManager.getCacheUsed()) &lt; bytesNeeded) &#123;</div><div class="line">    <span class="comment">// 获取待移除副本信息</span></div><div class="line">    RamDiskReplica replicaState = ramDiskReplicaTracker.getNextCandidateForEviction();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (replicaState == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">      LOG.debug(<span class="string">"Evicting block "</span> + replicaState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">// 移除内存中的相关块并释放空间</span></div><div class="line">      <span class="comment">// Delete the block+meta files from RAM disk and release locked</span></div><div class="line">      <span class="comment">// memory.</span></div><div class="line">      removeOldReplica(replicaInfo, newReplicaInfo, blockFile, metaFile,</div><div class="line">          blockFileUsed, metaFileUsed, bpid);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LazyWriter"><a href="#LazyWriter" class="headerlink" title="LazyWriter"></a>LazyWriter</h2><p>LazyWriter是一个线程服务,他是一个发动机,循环不断的从队列中取出待持久化的数据块,提交到异步持久化服务中去.直接来看主要的run方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> numSuccessiveFailures = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (fsRunning &amp;&amp; shouldRun) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// 取出新的副本块并提交到异步服务中,返回是否提交成功布尔值</span></div><div class="line">      numSuccessiveFailures = saveNextReplica() ? <span class="number">0</span> : (numSuccessiveFailures + <span class="number">1</span>);</div><div class="line"></div><div class="line">      <span class="comment">// Sleep if we have no more work to do or if it looks like we are not</span></div><div class="line">      <span class="comment">// making any forward progress. This is to ensure that if all persist</span></div><div class="line">      <span class="comment">// operations are failing we don't keep retrying them in a tight loop.</span></div><div class="line">      <span class="keyword">if</span> (numSuccessiveFailures &gt;= ramDiskReplicaTracker.numReplicasNotPersisted()) &#123;</div><div class="line">        Thread.sleep(checkpointerInterval * <span class="number">1000</span>);</div><div class="line">        numSuccessiveFailures = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      LOG.info(<span class="string">"LazyWriter was interrupted, exiting"</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      LOG.warn(<span class="string">"Ignoring exception in LazyWriter:"</span>, e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进入saveNextReplica方法的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">saveNextReplica</span><span class="params">()</span> </span>&#123;</div><div class="line">  RamDiskReplica block = <span class="keyword">null</span>;</div><div class="line">  FsVolumeReference targetReference;</div><div class="line">  FsVolumeImpl targetVolume;</div><div class="line">  ReplicaInfo replicaInfo;</div><div class="line">  <span class="keyword">boolean</span> succeeded = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 从队列种取出新的待持久化的块</span></div><div class="line">    block = ramDiskReplicaTracker.dequeueNextReplicaToPersist();</div><div class="line">    <span class="keyword">if</span> (block != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (FsDatasetImpl.<span class="keyword">this</span>) &#123;</div><div class="line">        ...</div><div class="line">        <span class="comment">// 提交到异步服务中去</span></div><div class="line">          asyncLazyPersistService.submitLazyPersistTask(</div><div class="line">              block.getBlockPoolId(), block.getBlockId(),</div><div class="line">              replicaInfo.getGenerationStamp(), block.getCreationTime(),</div><div class="line">              replicaInfo.getMetaFile(), replicaInfo.getBlockFile(),</div><div class="line">              targetReference);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    succeeded = <span class="keyword">true</span>;</div><div class="line">  &#125; <span class="keyword">catch</span>(IOException ioe) &#123;</div><div class="line">    LOG.warn(<span class="string">"Exception saving replica "</span> + block, ioe);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!succeeded &amp;&amp; block != <span class="keyword">null</span>) &#123;</div><div class="line">      LOG.warn(<span class="string">"Failed to save replica "</span> + block + <span class="string">". re-enqueueing it."</span>);</div><div class="line">      onFailLazyPersist(block.getBlockPoolId(), block.getBlockId());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> succeeded;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div align="center"><br> <img src="http://img.blog.csdn.net/20160529200024759" width="800" height="350" alt="图5" align="center"><br></div><br><div align="center"><br> 图五<br></div>

<p>所以LazyWriter线程服务的流程图可以归纳为如图四所示:</p>
<h2 id="RamDiskAsyncLazyPersistService"><a href="#RamDiskAsyncLazyPersistService" class="headerlink" title="RamDiskAsyncLazyPersistService"></a>RamDiskAsyncLazyPersistService</h2><p>RamDiskAsyncLazyPersistService主要围绕着Volume磁盘和Executor线程池这2部分的内容.秉持着下面一个原则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一个磁盘服务对应一个线程池,并且一个线程池的最大线程数也只有1个.</div></pre></td></tr></table></figure>
<p>线程池列表定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RamDiskAsyncLazyPersistService</span> </span>&#123;</div><div class="line">...</div><div class="line">  <span class="keyword">private</span> Map&lt;File, ThreadPoolExecutor&gt; executors</div><div class="line">      = <span class="keyword">new</span> HashMap&lt;File, ThreadPoolExecutor&gt;();</div><div class="line">...</div></pre></td></tr></table></figure>
<p>当服务启动的时候,就会有新的磁盘目录加入.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addVolume</span><span class="params">(File volume)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (executors == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"AsyncLazyPersistService is already shutdown"</span>);</div><div class="line">  &#125;</div><div class="line">  ThreadPoolExecutor executor = executors.get(volume);</div><div class="line">  <span class="comment">// 如果当前已存在此磁盘目录对应的线程池,则跑异常</span></div><div class="line">  <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Volume "</span> + volume + <span class="string">" is already existed."</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 否则进行添加</span></div><div class="line">  addExecutorForVolume(volume);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进入addExecutorForVolume方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addExecutorForVolume</span><span class="params">(<span class="keyword">final</span> File volume)</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="comment">// 新建线程池,最大线程执行数为</span></div><div class="line">  ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">      CORE_THREADS_PER_VOLUME, MAXIMUM_THREADS_PER_VOLUME,</div><div class="line">      THREADS_KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</div><div class="line">      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);</div><div class="line"></div><div class="line">  <span class="comment">// This can reduce the number of running threads</span></div><div class="line">  executor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</div><div class="line">  <span class="comment">// 加入到executors中,以为volume作为key</span></div><div class="line">  executors.put(volume, executor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一个需要注意的是提交执行方法<strong>submitLazyPersistTask</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">submitLazyPersistTask</span><span class="params">(String bpId, <span class="keyword">long</span> blockId,</span></span></div><div class="line">    <span class="keyword">long</span> genStamp, <span class="keyword">long</span> creationTime,</div><div class="line">    File metaFile, File blockFile,</div><div class="line">    FsVolumeReference target) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">    LOG.debug(<span class="string">"LazyWriter schedule async task to persist RamDisk block pool id: "</span></div><div class="line">        + bpId + <span class="string">" block id: "</span> + blockId);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 获取需要持久化到目标磁盘实例</span></div><div class="line">  FsVolumeImpl volume = (FsVolumeImpl)target.getVolume();</div><div class="line">  File lazyPersistDir  = volume.getLazyPersistDir(bpId);</div><div class="line">  <span class="keyword">if</span> (!lazyPersistDir.exists() &amp;&amp; !lazyPersistDir.mkdirs()) &#123;</div><div class="line">    FsDatasetImpl.LOG.warn(<span class="string">"LazyWriter failed to create "</span> + lazyPersistDir);</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"LazyWriter fail to find or create lazy persist dir: "</span></div><div class="line">        + lazyPersistDir.toString());</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 新建此服务Task</span></div><div class="line">  ReplicaLazyPersistTask lazyPersistTask = <span class="keyword">new</span> ReplicaLazyPersistTask(</div><div class="line">      bpId, blockId, genStamp, creationTime, blockFile, metaFile,</div><div class="line">      target, lazyPersistDir);</div><div class="line">  <span class="comment">// 提交到对应volume的线程池中执行</span></div><div class="line">  execute(volume.getCurrentDir(), lazyPersistTask);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在上述执行的过程中发生失败,会调用失败处理的方法,并会重新将此副本块插入到replicateNotPersisted队列等待下一次的持久化.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailLazyPersist</span><span class="params">(String bpId, <span class="keyword">long</span> blockId)</span> </span>&#123;</div><div class="line">  RamDiskReplica block = <span class="keyword">null</span>;</div><div class="line">  block = ramDiskReplicaTracker.getReplica(bpId, blockId);</div><div class="line">  <span class="keyword">if</span> (block != <span class="keyword">null</span>) &#123;</div><div class="line">    LOG.warn(<span class="string">"Failed to save replica "</span> + block + <span class="string">". re-enqueueing it."</span>);</div><div class="line">    <span class="comment">// 重新插入队列操作</span></div><div class="line">    ramDiskReplicaTracker.reenqueueReplicaNotPersisted(block);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div align="center"><br> <img src="http://img.blog.csdn.net/20160529200337300" width="800" height="350" alt="图6" align="center"><br></div><br><div align="center"><br> 图六<br></div>

<p>RamDiskAsyncLazyPersistService总的结构图图图5所示。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="安装RAM磁盘"><a href="#安装RAM磁盘" class="headerlink" title="安装RAM磁盘"></a>安装RAM磁盘</h2><p>使用Unix mount命令安装RAM磁盘分区。 例如。 在/ mnt / dn-tmpfs /下安装32 GB tmpfs分区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mount -t tmpfs -o size = 32g tmpfs / mnt / dn-tmpfs /</div></pre></td></tr></table></figure>
<p>建议您在/ etc / fstab中创建一个条目，以便在节点重新启动时自动重新创建RAM磁盘。 另一个选项是使用/ dev / shm下的子目录，它是默认情况下在大多数Linux发行版上可用的tmpfs安装。 确保安装的大小大于或等于您的dfs.datanode.max.locked.memory设置，否则在/ etc / fstab中重写它。 不建议对每个数据节点使用多个tmpfs分区进行Lazy Persist写入。</p>
<h2 id="使用RAM-DISK存储类型标记tmpfs卷"><a href="#使用RAM-DISK存储类型标记tmpfs卷" class="headerlink" title="使用RAM_DISK存储类型标记tmpfs卷"></a>使用RAM_DISK存储类型标记tmpfs卷</h2><p>通过hdfs-site.xml中的dfs.datanode.data.dir配置设置将tmpfs目录标记为RAM_DISK存储类型。 例如。 在具有三个硬盘卷/ grid / 0，/ grid / 1和/ grid / 2和tmpfs mount / mnt / dn-tmpfs的数据节点上，必须按如下所示设置dfs.datanode.data.dir：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>/grid/0,/grid/1,/grid/2,[RAM_DISK]/mnt/dn-tmpfs<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这一步是至关重要的。 如果没有RAM_DISK标记，HDFS会将tmpfs卷视为非易失性存储，并且数据不会保存到永久存储。 您将在节点重新启动时丢失数据。</p>
<h2 id="启用存储策略"><a href="#启用存储策略" class="headerlink" title="启用存储策略"></a>启用存储策略</h2><p>使用上面提到的LAZY_PERSIST,而不是使用默认的StoragePolicy.DEFAULT,默认策略的存储介质是DISK类型的.设置存储策略的方法目前有2种:</p>
<ul>
<li>第一种,通过命令行的方式,调用如下命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hdfs storagepolicies -setStoragePolicy -path &lt;path&gt; -policy LAZY_PERSIST</div></pre></td></tr></table></figure>
<ul>
<li>第二种,通过调用对应的程序方法,比如调用暴露到外部的create文件方法,但是得带上参数CreateFlag.LAZY_PERSIST.例子如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FSDataOutputStream fos =</div><div class="line">        fs.create(</div><div class="line">            path,</div><div class="line">            FsPermission.getFileDefault(),</div><div class="line">            EnumSet.of(CreateFlag.CREATE, CreateFlag.LAZY_PERSIST),</div><div class="line">            bufferLength,</div><div class="line">            replicationFactor,</div><div class="line">            blockSize,</div><div class="line">            <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/MemoryStorage.html" title="Memory Storage Support in HDFS" target="_blank" rel="external">Memory Storage Support in HDFS</a></li>
<li><a href="http://blog.csdn.net/androidlushangderen/article/details/51514216" title="HDFS内存存储" target="_blank" rel="external">HDFS内存存储 - 走在前往架构师的路上 - CSDN博客</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/hdfs/" rel="tag"># hdfs</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/08/maven_conflict/" rel="next" title="Maven依赖冲突解决">
                <i class="fa fa-chevron-left"></i> Maven依赖冲突解决
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="韩思明" />
          <p class="site-author-name" itemprop="name">韩思明</p>
           
              <p class="site-description motion-element" itemprop="description">专注于大数据，云计算，Java后端</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hansiming" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码"><span class="nav-number">2.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RamDiskReplicaLruTracker"><span class="nav-number">2.1.</span> <span class="nav-text">RamDiskReplicaLruTracker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LazyWriter"><span class="nav-number">2.2.</span> <span class="nav-text">LazyWriter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RamDiskAsyncLazyPersistService"><span class="nav-number">2.3.</span> <span class="nav-text">RamDiskAsyncLazyPersistService</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置"><span class="nav-number">3.</span> <span class="nav-text">配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装RAM磁盘"><span class="nav-number">3.1.</span> <span class="nav-text">安装RAM磁盘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用RAM-DISK存储类型标记tmpfs卷"><span class="nav-number">3.2.</span> <span class="nav-text">使用RAM_DISK存储类型标记tmpfs卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启用存储策略"><span class="nav-number">3.3.</span> <span class="nav-text">启用存储策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">4.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">韩思明</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
